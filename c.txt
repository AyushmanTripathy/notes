from:- learn-c.org

C Programming Language

STRINGS
  initialize strings

    char a[] = "your strings"; // array
    char * a = "your strings"; // pointer

  include string.h  // adds string functions

  functions
  strlen(str)     | returns string length
  strcat(a,b)     | add b to a
  strncat(a,b,i)  | adds i letters of b at end of a
  sizeof(var)     | returns memory size, one null at end
  strcpy(a,b)     | copies b to a
  strcmp(a,b)     | compares a to b (0 for equal)

LOOPS
  while and for loops
  continue skips loop
  break halts loop

FUNCTIONS
  functions should be first declared

    int foo(int bar);
    int main() {
      foo(1);
    }
    int foo(int bar) {
        return bar + 1;
    }
  
  void keyword for not returning
  static keyword used to reduce scope
  by default functions are global

    static void foo(void) {}

  REFRENCING BY ARGUMENTS
    give memory address as argument to a function

      void inc(int * n) {
        (*n)++;
      }
      int n;
      inc(&n);
      printf("%d",n) // gives 1


STATIC VARIABLES
  static keyword for increasing scope of variables
  by default variables are local

    int counter() {
        static int count = 0;
        count++;
        return count;
    } int main() {
        printf("%d ", counter());
        printf("%d ", counter());
        return 0;
    }

  returns number of times function is called.

STRUCTURES
  defining custom data types
    
    struct point { int x; int y; };
    struct point p;
    p.x = 10; p.y = 5;
  
  typedef are used to define custom type

    typedef struct {
      char * brand;
      int model;
    } vehicle;
    vehicle mycar;
    mycar.name = "Ford";

POINTERS
  is a integer variable holding memory address pointing to a value.
    
    char * name = "John";

  "John" is stored sequentially in memory,
  name points to "J" (first char)
  \0 is null terminator (value is 0)

  DEREFRENCING
    getting the value not the memmory address of a pointer
    arrays are actually pointers
    [] operator does derefrencing for arrays
    * does dereferencing for pointers

      int a = 1;
      int * pointer = &a;
      printf("%d",*pointer) // gives 1
      *pointer += 1;
      printf("%d",*pointer) // gives 2

  POINTERS TO STRUCTURES
    can be done using two syntax
      
      void move(point * p) {
        (*p).distance++;
      }
      void move(point * p ) {
        p -> distance++; 
      }

  ARRAYS
    arrays can be simulated as
      
      char * vowels = "AEIOU";
      char p = &vowels;
      vowels[1] == *(p + 1) //true

DYNAMIC ALLOCATION
  helps in storing data with out knowing its size
    
    person * me = (person *) malloc(sizeof(person));
    me -> name = "John";

  me is a pointer, has just enough memory to store person struct
  malloc function returns a `void pointer`
  (person *) is called typecasting (changes pointer's type)
    
    free(me);

  frees the memory
  note: sizeof is not actual function
